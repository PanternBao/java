提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。

最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。

简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。

## 事务的特点

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），之间的关系

隔离性，多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性，事务一旦提交，他对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

原子性，事务是一个不可分割的单位，其中的操作要么都做，要么都不做。若无法保证原子性，数据不一致的情况，需要业务自己去保证一致性。保证事务的原子性不一定能保证一致性，比如并发事务的数据更新问题。

一致性

## 事务并发带来的问题

并发事务处理也会带来一些问题，这些问题可以归结为5类，包括3类数据读问题（脏读、不可重复读和幻读）以及2类数据更新问题（第一类丢失更新和 第二类丢失更新）。

1. 更新丢失（`Lost Update`）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。（写，写）

   第一类更新

   A事务撤销时，把已经提交的B事务的更新数据覆盖了。

   第二类更新

   A事务覆盖B事务已经提交的数据 ，造成B事务所做操作丢失：

2. 脏读（`Dirty Reads`）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 **“脏读”**。（写，读）

3. 不可重复读（`Non-Repeatable Reads`）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。读写

4. 幻读（`Phantom Reads`）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 **“幻读”**。

为了解决这些问题，就有了“隔离级别”的概念。但是隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

| 事务 A              | 事务 B      |
| ------------------- | ----------- |
| 启动事务查询得到值1 | 启动事务    |
|                     | 查询得到值1 |
|                     | 将1改成2    |
| 查询得到值v1        |             |
|                     | 提交事务B   |
| 查询得到值v2        |             |
| 提交事务A           |             |
| 查询得到值v3        |             |

我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，V1、V2、V3 的返回值分别是什么。

| 隔离级别 | v1   | v2   | v3   |
| -------- | ---- | ---- | ---- |
| 读未提交 | 2    | 2    | 2    |
| 读提交   | 1    | 2    | 2    |
| 可重复读 | 1    | 1    | 2    |
| 串行化   | 1    | 1    | 1    |

若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

## 事务隔离的实现

以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供事务间的隔离机制来解决。实现隔离机制的方法主要有两种：

1. 加读写锁
2. 一致性快照读，即 `MVCC`

事务隔离的实现

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。



sql_parse.cc

```
bool dispatch_command(THD *thd, const COM_DATA *com_data,
                      enum enum_server_command command) {
```

https://blog.csdn.net/scugxl/article/details/102807330