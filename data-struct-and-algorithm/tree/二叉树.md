二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？

## 树（Tree）

### 定义

![tree](../pics/tree.jpg)

每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。

特点

- 根节点 - 没有父节点
- 层级结构

父节点，子节点，兄弟节点，根节点，叶子结点，叶结点 的概念

关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：

- 节点高度：节点到叶子结点的最长路径（边数）
- 节点深度：根结点到这个节点所经历的边的个数
- 节点的层数：节点的深度 + 1
- 树的高度：根节点的高度

![tree_height](../pics/tree_height.jpg)

记这几个概念，我还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。

在我们的生活中，“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。

“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。

“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。

## 二叉树（Binary Tree）

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。

完全二叉树：最后一层的叶子节点都靠左排列。

满二叉树：每层的叶子结点数达到最大。

那我们为什么还要特意把它拎出来讲呢？为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？要理解完全二叉树定义的由来，我们需要先了解，如何表示（或者存储）一棵二叉树？

想要存储一棵二叉树，我们有两种方法：

1. 基于指针或者引用的二叉链式存储法。大部分二叉树代码都是通过这种结构来实现的。节点需要存储数据和指针，占用空间。
2. 基于数组的顺序存储法。可以通过数组的下标得出当前节点的父节点，左右节点的下标。

如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。

所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

## 二叉树的遍历

如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

<img src="../pics/traverse.jpg" alt="traverse" style="zoom:67%;" />

实际上，二叉树的前、中、后序遍历就是一个递归的过程。

遍历的时间复杂度是 O(n)

空间复杂度

广度优先和深度优先

https://mp.weixin.qq.com/s/0b5OsnFLLg18Td4CuR51_Q