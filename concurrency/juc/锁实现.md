锁实现

自旋

```java
volatile int status=0;

void lock(){
	
	while(!compareAndSet(0,1)){}
	// 临界区
}

void unlock(){
	status=0;
}

boolean compareAndSet(int except,int newValue){
	//cas操作,修改status成功则返回true
}

```

致命的缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费10s处理业务逻辑，那另外一个线程就会白白的花费10s的cpu资源。

对于锁冲突不严重的情况，用自旋锁会更适合，试想每个线程获得锁后很短的一段时间内就释放锁，竞争锁的线程只要经历几次自旋运算后就能获得锁，那就没必要等待该线程了，因为等待线程意味着需要进入到内核态进行上下文切换，而上下文切换是有成本的并且还不低，如果锁很快就释放了，那上下文切换的开销将超过自旋。

### yield+自旋

```java
volatile int status=0;

void lock(){
	
	while(!compareAndSet(0,1)){
    // 释放cpu
    yield();
  }
	// 临界区
}

void unlock(){
	status=0;
}

boolean compareAndSet(int except,int newValue){
	//cas操作,修改status成功则返回true
}

```

取决于内核的任务调度，若该任务优先级较高，下次可能还是运行该任务，这样Cpu 利用率会很低，全部消耗在上下文切换上。假如运行在单核cpu下，在竞争锁时最差只有1%的cpu利用率，导致获得锁的线程1一直被中断，执行实际业务代码时间变得更长，从而导致锁释放的时间变的更长。

### sleep+自旋

```java
volatile int status=0;

void lock(){
	
	while(!compareAndSet(0,1)){
    // 任务睡眠10ms
    sleep(10);
  }
	// 临界区
}

void unlock(){
	status=0;
}

boolean compareAndSet(int except,int newValue){
	//cas操作,修改status成功则返回true
}

```

睡眠时间很难设置

### park+自旋

那可不可以在获取不到锁的时候让线程释放cpu资源进行等待，当持有锁的线程释放锁的时候将等待的线程唤起呢？

```java
volatile int status=0;

Queue parkQueue;

void lock(){
	
	while(!compareAndSet(0,1)){
		lock_wait();
	}
	// 临界区

}

void synchronized  unlock(){
	lock_notify();
}

void lock_wait(){
	// 将当期线程加入到等待队列
	parkQueue.add(nowThread);
	// 将当期线程释放cpu
	releaseCpu();
}
void lock_notify(){
	// 得到要唤醒的线程
	Thread t=parkList.poll();
	// 唤醒等待线程
	wakeAThread(t);
}
```

内核提供的同步机制，如semaphore等，使用的是上文说的自旋+等待的形式。 它对于大小临界区都适用。但是因为它是内核层的（释放cpu资源是内核级调用），所以每次lock与unlock都是一次系统调用，即使没有锁冲突，也必须要通过系统调用进入内核之后才能识别。

下面介绍下内核中semaphore的实现：

数据结构：

```c++
struct semaphore {
  // 自旋锁
	raw_spinlock_t		lock;
  // 相当于信号量的值，大于0，资源空闲；等于0，资源忙，但没有进程等待这个保护的资源；小于0，资源不可用，并至少有一个进程等待资源
	unsigned int		count;
  // 存放等待队列链表的地址，当前等待资源的所有睡眠进程都会放在这个链表中
	struct list_head	wait_list;
};
```

down操作

```c++
void down(struct semaphore *sem)
{
	unsigned long flags;
	// 加自旋锁，保证 count--和将任务放入等待队列的一致性
	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		__down(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}

static noinline void __sched __down(struct semaphore *sem)
{
	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}

static inline int __sched __down_common(struct semaphore *sem, long state,
								long timeout)
{
	struct semaphore_waiter waiter;
	// 将当前任务放入等待队列
	list_add_tail(&waiter.list, &sem->wait_list);
	waiter.task = current;
	waiter.up = false;

	for (;;) {
		if (signal_pending_state(state, current))
			goto interrupted;
    // 超时
		if (unlikely(timeout <= 0))
			goto timed_out;
    // 设置状态
		__set_current_state(state);
		raw_spin_unlock_irq(&sem->lock);
		timeout = schedule_timeout(timeout);
		raw_spin_lock_irq(&sem->lock);
		if (waiter.up)
			return 0;
	}

 timed_out:
	list_del(&waiter.list);
	return -ETIME;

 interrupted:
	list_del(&waiter.list);
	return -EINTR;
}
```

up操作

```c++
void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}

static noinline void __sched __up(struct semaphore *sem)
{
	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
						struct semaphore_waiter, list);
	list_del(&waiter->list);
	waiter->up = true;
  // 唤醒当前任务
	wake_up_process(waiter->task);
}
```

理想的同步机制应该是没有锁冲突时在用户态利用原子指令就解决问题，而需要挂起等待时再使用内核提供的系统调用进行睡眠与唤醒。换句话说，在用户态的自旋失败时，能不能让进程挂起，由持有锁的线程释放锁时将其唤醒？ 如果你没有较深入地考虑过这个问题，很可能想当然的认为类似于这样就行了（伪代码）：

```c++
void lock(int lockval) {
	// trylock是用户级的自旋锁
	while(!trylock(lockval)) {
    // 释放cpu，并将当期线程加入等待队列，是系统调用
		wait();
	}
}

boolean trylock(int lockval){
	int i=0; 
	// localval=1代表上锁成功
	while(!compareAndSet(lockval,0,1)){
		if(++i>10){
			return false;
		}
	}
	return true;
}

void unlock(int lockval) {
	 compareAndSet(lockval,1,0);
	 notify();
}
```

上述代码的问题是trylock和wait两个调用之间存在一个窗口：
如果一个线程trylock失败，在调用wait时持有锁的线程释放了锁，当前线程还是会调用wait进行等待，但之后就没有人再将该线程唤醒了。

Futex 如何解决这个问题？？？

目前操作系统中，一般是用自旋+等待结合的形式实现锁：在进入锁时先自旋一定次数，如果还没获得锁再进行等待。

在futex诞生之前，linux下的同步机制可以归为两类：用户态的同步机制 和内核同步机制。 用户态的同步机制基本上就是利用原子指令实现的自旋锁。关于自旋锁其缺点也说过了，不适用于大的临界区（即锁占用时间比较长的情况）。